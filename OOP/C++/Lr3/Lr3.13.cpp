#include <iostream>

// Клас stack з прикладу другої лекції
class stack
{
  char stck[30]; // збільшуємо розмір до 30, щоб вистачило для алфавіту
  int tos;

public:
  // Конструктор
  stack()
  {
    tos = 0;
  }

  // Розміщення елемента в стек
  void push(char ch)
  {
    if (tos == 30)
    {
      std::cout << "Стек заповнений!" << std::endl;
      return;
    }
    stck[tos] = ch;
    tos++;
  }

  // Вилучення елемента зі стеку
  char pop()
  {
    if (tos == 0)
    {
      std::cout << "Стек порожній!" << std::endl;
      return 0;
    }
    tos--;
    return stck[tos];
  }

  // Перевірка, чи стек порожній
  bool isEmpty()
  {
    return tos == 0;
  }

  // Перевірка, чи стек заповнений
  bool isFull()
  {
    return tos == 30;
  }

  // Отримання поточної позиції вершини стеку
  int getSize()
  {
    return tos;
  }
};

// Функція для завантаження стеку символами алфавіту від 'a' до 'z'
stack loadstack()
{
  stack s;

  // Перевіряємо, чи достатньо місця в стеку (нам потрібно 26 місць для літер від 'a' до 'z')
  if (s.getSize() + 26 > 30)
  {
    std::cout << "Недостатньо місця в стеку для алфавіту!" << std::endl;
    return s;
  }

  // Заповнюємо стек літерами від 'a' до 'z'
  for (char ch = 'a'; ch <= 'z'; ch++)
  {
    s.push(ch);
  }

  return s;
}

// Перевантажена функція для завантаження стеку символами алфавіту
// у верхньому або нижньому регістрі в залежності від параметра upper
stack loadstack(int upper)
{
  stack s;

  // Перевіряємо, чи достатньо місця в стеку
  if (s.getSize() + 26 > 30)
  {
    std::cout << "Недостатньо місця в стеку для алфавіту!" << std::endl;
    return s;
  }

  if (upper == 1)
  {
    // Заповнюємо стек літерами від 'A' до 'Z' (верхній регістр)
    for (char ch = 'A'; ch <= 'Z'; ch++)
    {
      s.push(ch);
    }
  }
  else
  {
    // Заповнюємо стек літерами від 'a' до 'z' (нижній регістр)
    for (char ch = 'a'; ch <= 'z'; ch++)
    {
      s.push(ch);
    }
  }

  return s;
}

// Функція для виведення вмісту стеку
void showStack(stack s)
{
  std::cout << "Вміст стеку (від вершини до дна):" << std::endl;

  if (s.isEmpty())
  {
    std::cout << "Стек порожній!" << std::endl;
    return;
  }

  // Створюємо тимчасовий стек для зберігання вилучених елементів
  stack tempStack;

  // Вилучаємо і виводимо елементи зі стеку
  while (!s.isEmpty())
  {
    char ch = s.pop();
    std::cout << ch << " ";
    tempStack.push(ch);
  }
  std::cout << std::endl;

  // Повертаємо елементи назад у стек
  while (!tempStack.isEmpty())
  {
    s.push(tempStack.pop());
  }
}

int main()
{
  // Створюємо стек, заповнений алфавітом за замовчуванням (нижній регістр)
  std::cout << "Створюємо стек з алфавітом у нижньому регістрі:" << std::endl;
  stack s1 = loadstack();

  // Показуємо вміст стеку
  showStack(s1);

  // Перевіряємо, що вилучення елементів працює правильно
  std::cout << "\nПеревіряємо вилучення 5 елементів зі стеку s1:" << std::endl;
  for (int i = 0; i < 5; i++)
  {
    std::cout << "Вилучено: " << s1.pop() << std::endl;
  }

  // Показуємо вміст стеку після вилучення
  std::cout << "\nСтек s1 після вилучення 5 елементів:" << std::endl;
  showStack(s1);

  // Створюємо стек з алфавітом у верхньому регістрі
  std::cout << "\nСтворюємо стек з алфавітом у верхньому регістрі:" << std::endl;
  stack s2 = loadstack(1);

  // Показуємо вміст стеку
  showStack(s2);

  // Створюємо стек з алфавітом у нижньому регістрі, використовуючи перевантажену функцію
  std::cout << "\nСтворюємо стек з алфавітом у нижньому регістрі (з параметром 0):" << std::endl;
  stack s3 = loadstack(0);

  // Показуємо вміст стеку
  showStack(s3);

  return 0;
}