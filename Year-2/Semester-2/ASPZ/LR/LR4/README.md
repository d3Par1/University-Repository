# Лабораторна робота №4
**Тема:** Динамічне керування пам'яттю: malloc(3), realloc(3), reallocarray(3)

## Мета роботи
Дослідити особливості динамічного виділення пам'яті в C, типові помилки при роботі з malloc/realloc/free, а також порівняти реалізації менеджерів пам'яті у glibc та musl.

---

## Компіляція та запуск

### Збірка всіх завдань
```bash
make all
```

### Очистка
```bash
make clean
```

---

## Виконання завдань

### Завдання 4.1: Максимальний розмір пам'яті, що може виділити malloc(3)
Проаналізовано, який максимальний обсяг пам'яті може бути виділений за один виклик malloc(3). Параметр malloc є типу size_t, тому на 64-бітній системі теоретичний максимум — 2^64 байтів (16 ексабайт). Однак практичний ліміт обмежений архітектурою: x86_64 використовує лише 48-бітну адресацію (256 ТБ), а ядро Linux резервує верхню половину, залишаючи ~128 ТБ для користувацького простору. ptrdiff_t (знаковий тип) додатково обмежує до ~8 ЕБ.

## [Код до завдання](task4.1/max_malloc.c)

---

### Завдання 4.2: Використання malloc(3) з від'ємним аргументом
Досліджено поведінку malloc при передачі від'ємного значення. Оскільки malloc приймає size_t (беззнаковий тип), від'ємне число інтерпретується як дуже велике позитивне, що призводить до невдалого виділення пам'яті. Також розглянуто випадок переповнення при множенні двох чисел перед передачею в malloc.

## [Код до завдання](task4.2/negative_malloc.c)

---

### Завдання 4.3: Використання malloc(0)
Протестовано поведінку malloc(0). За стандартом C malloc(0) може повернути або NULL, або валідний вказівник, який можна передати free(). Поведінка залежить від реалізації: glibc повертає унікальний ненульовий вказівник для кожного виклику.

## [Код до завдання](task4.3/malloc_zero.c)

---

### Завдання 4.4: Аналіз помилки в коді з malloc(3)
Проаналізовано класичну помилку use-after-free:

```c
void *ptr = NULL;
while (<condition>) {
    if (!ptr)
        ptr = malloc(n);
    /* використання ptr */
    free(ptr);       // ptr не скидається в NULL!
}
```

Після free(ptr) вказівник зберігає стару адресу (dangling pointer). На наступній ітерації `(!ptr)` хибне, malloc пропускається, і використовується звільнена пам'ять — це undefined behavior.

**Виправлення:** додати `ptr = NULL;` після `free(ptr);`

## [Код до завдання](task4.4/malloc_bug.c)

---

### Завдання 4.5: Якщо realloc(3) не зможе виділити пам'ять
Протестовано поведінку realloc при невдалому виділенні. Функція повертає NULL, але старий вказівник не звільняється. Важливо зберігати старий вказівник перед викликом realloc, щоб уникнути витоку пам'яті:

```c
void *tmp = realloc(ptr, new_size);
if (tmp == NULL) {
    // ptr все ще валідний!
} else {
    ptr = tmp;
}
```

## [Код до завдання](task4.5/realloc_fail.c)

---

### Завдання 4.6: Використання realloc(3) з NULL або розміром 0
Перевірено дві граничні ситуації:
1. `realloc(NULL, size)` — еквівалент `malloc(size)`
2. `realloc(ptr, 0)` — поведінка залежить від реалізації, може працювати як `free(ptr)`

## [Код до завдання](task4.6/realloc_null_zero.c)

---

### Завдання 4.7: Використання reallocarray(3)
Переписано код з realloc на reallocarray, який перевіряє переповнення при множенні nmemb × size перед виділенням. Це запобігає класичній вразливості integer overflow при обчисленні розміру масиву.

```c
// Небезпечно: можливе переповнення
ptr = realloc(ptr, nmemb * size);

// Безпечно: перевірка переповнення
ptr = reallocarray(ptr, nmemb, size);
```

## [Код до завдання](task4.7/reallocarray_test.c)

---

### Варіантне Завдання 15: Порівняння malloc у glibc та musl
Проведено порівняльний аналіз реалізацій malloc у glibc та musl:

| Характеристика | glibc (ptmalloc2) | musl |
|---|---|---|
| **Накладні витрати** | Більші метадані | Мінімальні |
| **Фрагментація** | Складні алгоритми зменшення | Простіша стратегія |
| **Багатопотоковість** | Арени для потоків | Єдиний м'ютекс |
| **Оптимізація** | Швидкість | Мінімальне використання пам'яті |

**Висновок:** musl краще підходить для вбудованих систем з обмеженими ресурсами, glibc — для серверних програм з інтенсивним використанням пам'яті та багатопотоковістю.

## [Код до завдання](variant15/glibc_vs_musl.c)

---

## Висновок
Правильне керування пам'яттю є критично важливим для стабільної роботи програм. Використання malloc(3), realloc(3), calloc(3) та reallocarray(3) вимагає перевірки результатів та обережного поводження для запобігання витокам пам'яті, переповненню та use-after-free помилкам. reallocarray(3) забезпечує безпечніше виділення пам'яті завдяки перевірці переповнення. Різні реалізації бібліотек C мають власні підходи до управління пам'яттю, що впливає на продуктивність та використання ресурсів.
