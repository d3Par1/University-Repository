# Лабораторна робота №4
**Тема:** Динамічне керування пам'яттю: malloc(3), realloc(3), reallocarray(3)

## Мета роботи
Дослідити особливості динамічного виділення пам'яті в C, типові помилки при роботі з malloc/realloc/free, а також реалізувати перехоплення malloc/free для виявлення витоків пам'яті.

---

## Компіляція та запуск

### Збірка всіх завдань
```bash
make all
```

### Очистка
```bash
make clean
```

---

## Виконання завдань

### Завдання 4.1: Максимальний розмір пам'яті, що може виділити malloc(3)
Проаналізовано, який максимальний обсяг пам'яті може бути виділений за один виклик malloc(3). Параметр malloc є типу size_t, тому на 64-бітній системі теоретичний максимум — 2^64 байтів (16 ексабайт). Однак практичний ліміт обмежений архітектурою: x86_64 використовує лише 48-бітну адресацію (256 ТБ), а ядро Linux резервує верхню половину, залишаючи ~128 ТБ для користувацького простору. ptrdiff_t (знаковий тип) додатково обмежує до ~8 ЕБ.

## [Код до завдання](task4.1/max_malloc.c)

---

### Завдання 4.2: Використання malloc(3) з від'ємним аргументом
Досліджено поведінку malloc при передачі від'ємного значення. Оскільки malloc приймає size_t (беззнаковий тип), від'ємне число інтерпретується як дуже велике позитивне, що призводить до невдалого виділення пам'яті. Також розглянуто випадок переповнення при множенні двох чисел перед передачею в malloc.

## [Код до завдання](task4.2/negative_malloc.c)

---

### Завдання 4.3: Використання malloc(0)
Протестовано поведінку malloc(0). За стандартом C malloc(0) може повернути або NULL, або валідний вказівник, який можна передати free(). Поведінка залежить від реалізації: glibc повертає унікальний ненульовий вказівник для кожного виклику.

## [Код до завдання](task4.3/malloc_zero.c)

---

### Завдання 4.4: Аналіз помилки в коді з malloc(3)
Проаналізовано класичну помилку use-after-free:

```c
void *ptr = NULL;
while (<condition>) {
    if (!ptr)
        ptr = malloc(n);
    /* використання ptr */
    free(ptr);       // ptr не скидається в NULL!
}
```

Після free(ptr) вказівник зберігає стару адресу (dangling pointer). На наступній ітерації `(!ptr)` хибне, malloc пропускається, і використовується звільнена пам'ять — це undefined behavior.

**Виправлення:** додати `ptr = NULL;` після `free(ptr);`

## [Код до завдання](task4.4/malloc_bug.c)

---

### Завдання 4.5: Якщо realloc(3) не зможе виділити пам'ять
Протестовано поведінку realloc при невдалому виділенні. Функція повертає NULL, але старий вказівник не звільняється. Важливо зберігати старий вказівник перед викликом realloc, щоб уникнути витоку пам'яті:

```c
void *tmp = realloc(ptr, new_size);
if (tmp == NULL) {
    // ptr все ще валідний!
} else {
    ptr = tmp;
}
```

## [Код до завдання](task4.5/realloc_fail.c)

---

### Завдання 4.6: Використання realloc(3) з NULL або розміром 0
Перевірено дві граничні ситуації:
1. `realloc(NULL, size)` — еквівалент `malloc(size)`
2. `realloc(ptr, 0)` — поведінка залежить від реалізації, може працювати як `free(ptr)`

## [Код до завдання](task4.6/realloc_null_zero.c)

---

### Завдання 4.7: Використання reallocarray(3)
Переписано код з realloc на reallocarray, який перевіряє переповнення при множенні nmemb × size перед виділенням. Це запобігає класичній вразливості integer overflow при обчисленні розміру масиву.

```c
// Небезпечно: можливе переповнення
ptr = realloc(ptr, nmemb * size);

// Безпечно: перевірка переповнення
ptr = reallocarray(ptr, nmemb, size);
```

## [Код до завдання](task4.7/reallocarray_test.c)

---

### Варіантне Завдання 15: Перехоплення malloc/free через обгортку з журналом виділень

Реалізовано перехоплення malloc() та free() за допомогою опції лінкера `--wrap`. Механізм працює так:

- Прапорець `-Wl,--wrap=malloc` замінює всі виклики `malloc` на `__wrap_malloc`
- Всередині `__wrap_malloc` виклик `__real_malloc` дозволяє звернутися до справжнього malloc з libc
- Кожне виділення записується у зв'язний список (`AllocRecord` з адресою та розміром)
- Кожне звільнення видаляє запис зі списку
- При завершенні програми (через `atexit`) виводиться звіт про всі незвільнені блоки

**Тестовий сценарій:** програма виконує кілька виділень пам'яті, частину з яких навмисно не звільняє. При виході друкується звіт:

```
=== LEAK REPORT (malloc/free wrapper) ===
  Unfreed block: addr=0x..., size=800
  Unfreed block: addr=0x..., size=50
  Unfreed block: addr=0x..., size=128
  Unfreed block: addr=0x..., size=32
  Unfreed block: addr=0x..., size=32
Summary: 10 allocation(s), 5 free(s)
```

**Важливий нюанс:** внутрішні записи (`AllocRecord`) виділяються через `__real_malloc`, а не через `malloc`, щоб уникнути нескінченної рекурсії.

**Компіляція та запуск:**
```bash
gcc -Wall -Wextra -std=c11 -O2 malloc_wrapper.c -o malloc_wrapper -Wl,--wrap=malloc,--wrap=free
./malloc_wrapper
```

## [Код до завдання](variant15/malloc_wrapper.c)

---

## Висновок
Правильне керування пам'яттю є критично важливим для стабільної роботи програм. Використання malloc(3), realloc(3), calloc(3) та reallocarray(3) вимагає перевірки результатів та обережного поводження для запобігання витокам пам'яті, переповненню та use-after-free помилкам. reallocarray(3) забезпечує безпечніше виділення пам'яті завдяки перевірці переповнення. Перехоплення malloc/free через механізм `--wrap` дозволяє створити власний інструмент для виявлення витоків пам'яті без зміни вихідного коду програми.
