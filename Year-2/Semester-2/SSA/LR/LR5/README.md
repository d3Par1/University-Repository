# Лабораторна робота №5
**Тема:** Про помилки роботи з пам'яттю в Linux та засоби їх усунення

## Мета роботи
Дослідити типові помилки при роботі з пам'яттю в C/C++ програмах під Linux: неініціалізовані змінні, вихід за межі масиву, витоки пам'яті, невизначена поведінка, фрагментація, "завислі" покажчики, подвійне звільнення, переповнення буфера, use-after-free та пошкодження пам'яті. Навчитися використовувати Valgrind для виявлення та діагностики цих помилок.

---

## Компіляція та запуск

### Збірка всіх завдань
```bash
make all
```

### Очистка
```bash
make clean
```

### Перевірка з Valgrind
```bash
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./task5.X/binary_name
```

---

## Виконання завдань

### Завдання 5.1: Неініціалізовані змінні (Uninitialized Variables)
Продемонстровано використання змінних до їх ініціалізації. Стек у C не обнуляється, тому локальні змінні містять "сміття" — залишки попередніх викликів функцій. Це призводить до непередбачуваних значень і непередбачуваного розгалуження логіки програми. Valgrind з опцією `--track-origins=yes` здатний відстежити джерело неініціалізованих даних.

## [Код до завдання](task5.1/uninitialized.c)

---

### Завдання 5.2: Вихід за межі масиву (Out-of-Bounds Access)
Продемонстровано читання та запис за межами виділеного масиву. На більшості систем це не викликає негайного краху, оскільки суміжна пам'ять знаходиться на тій самій сторінці MMU. Однак це призводить до тихого пошкодження даних — сусідні змінні можуть бути перезаписані без жодних повідомлень про помилку.

## [Код до завдання](task5.2/out_of_bounds.c)

---

### Завдання 5.3: Витік пам'яті (Memory Leak)
Продемонстровано три сценарії витоків: проста втрата вказівника при виході з функції, перепризначення вказівника без попереднього звільнення, та накопичення витоків у циклі. Valgrind класифікує витоки як "definitely lost", "indirectly lost", "possibly lost" та "still reachable".

## [Код до завдання](task5.3/memory_leak.c)

---

### Завдання 5.4: Невизначена поведінка (Undefined Behavior)
Продемонстровано декілька форм невизначеної поведінки: порушення точок послідовності (`a++ + ++a`), переповнення знакового цілого типу, ділення на нуль та зсув на кількість бітів, що перевищує ширину типу. Результати UB залежать від компілятора та рівня оптимізації — код, що "працює" з `-O0`, може зламатися з `-O2`.

## [Код до завдання](task5.4/undefined_behavior.c)

---

### Завдання 5.5: Фрагментація пам'яті (Memory Fragmentation)
Змодельовано фрагментацію heap-пам'яті шляхом виділення великої кількості дрібних блоків та звільнення кожного другого. Це створює "решето" з вільних проміжків, де кожен окремий блок занадто малий для великої алокації, хоча загальний обсяг вільної пам'яті достатній. Сучасні алокатори (glibc) можуть обійти це через `mmap`, але проблема залишається актуальною для вбудованих систем.

## [Код до завдання](task5.5/fragmentation.c)

---

### Завдання 5.6: "Завислий" покажчик (Dangling Pointer)
Продемонстровано ситуацію, коли після `free(p)` покажчик зберігає стару адресу. Читання через такий покажчик може випадково повернути старе значення, але алокатор вже міг перевикористати цей блок для іншої алокації. Показано безпечний патерн: завжди встановлювати `p = NULL` після `free(p)`.

## [Код до завдання](task5.6/dangling_pointer.c)

---

### Завдання 5.7: Подвійне звільнення (Double Free)
Продемонстровано наслідки виклику `free()` двічі для одного блоку пам'яті. Це пошкоджує внутрішні структури алокатора та може призвести до краху програми або heap poisoning — атаки на безпеку. Показано також проблему з аліасами покажчиків, де два різних вказівники вказують на один блок.

## [Код до завдання](task5.7/double_free.c)

---

### Завдання 5.8: Переповнення буфера (Buffer Overflow)
Продемонстровано запис за межі буфера на стеку та у heap. Переповнення стекового буфера може перезаписати return-адресу (класичний експлойт). Переповнення heap-буфера пошкоджує метадані алокатора або сусідні дані. Показано безпечну альтернативу з `strncpy` замість `strcpy`.

## [Код до завдання](task5.8/buffer_overflow.c)

---

### Завдання 5.9: Use-After-Free
Продемонстровано звернення до пам'яті після її звільнення. Алокатор може перевикористати блок для нової алокації, тому читання через старий покажчик повертає чужі дані, а запис тихо пошкоджує нові об'єкти. Use-after-free є однією з найбільш експлуатованих вразливостей (CWE-416).

## [Код до завдання](task5.9/use_after_free.c)

---

### Завдання 5.10: Пошкодження пам'яті (Memory Corruption)
Продемонстровано тихе пошкодження пам'яті через запис за межі одної структури даних. Баг проявляється далеко від місця помилки — запис в `a[5]` може зіпсувати змінну `b`, розміщену поруч. Показано пошкодження через `memcpy` з неправильним розміром та переповнення поля структури.

## [Код до завдання](task5.10/memory_corruption.c)

---

### Варіантне Завдання 15: Циклічні посилання у динамічних структурах даних
Реалізовано динамічну структуру даних (граф на основі двозв'язного списку) з додатковими перехресними посиланнями, що створюють цикли. Продемонстровано, що наївний підхід зі підрахунком посилань (reference counting) не може звільнити вузли у циклі — лічильник посилань ніколи не досягає нуля.

Структура вузла:

```c
typedef struct Node {
    int id;
    char *data;
    struct Node *next;      // зв'язний список
    struct Node *prev;      // зворотній зв'язок
    struct Node *ref;       // перехресне посилання (створює цикл)
} Node;
```

Створені цикли: Node 1 → Node 3 → Node 1 та Node 2 → Node 4 → Node 2.

**Проблема:** при підрахунку посилань вузли у циклі завжди мають refcount > 0, тому їх неможливо звільнити.

**Рішення:** двофазний підхід:
1. **Фаза 1:** обнулення всіх циклічних посилань (`ref = NULL`)
2. **Фаза 2:** послідовне звільнення всіх вузлів

Перевірка з Valgrind:
```bash
valgrind --leak-check=full ./variant15/cyclic_refs
```

## [Код до завдання](variant15/cyclic_refs.c)

---

## Параметри Valgrind

| Параметр | Опис |
|---|---|
| `--leak-check=full` | Повний звіт про витоки пам'яті |
| `--show-leak-kinds=all` | Показати всі типи витоків |
| `--track-origins=yes` | Відстежити джерело неініціалізованих даних |
| `--log-file=valgrind.log` | Зберегти результат у файл |

---

## Висновок
Правильне керування пам'яттю є критично важливим для стабільності та безпеки програм на C/C++. Навіть незначні помилки, як вихід за межі масиву на один елемент, можуть призвести до руйнування структур даних, витоків пам'яті та вразливостей безпеки. Valgrind є незамінним інструментом для виявлення таких помилок: він визначає витоки, доступ до звільненої пам'яті, подвійне звільнення та вихід за межі. Для циклічних структур даних необхідно застосовувати спеціальні стратегії звільнення — або двофазний підхід (розрив циклів + звільнення), або механізми збирання сміття (mark-and-sweep), або слабкі посилання (weak references).
